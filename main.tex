\documentclass{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[polish]{babel}

% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{pgfplots}

\title{Praca inżynierska}
\author{ehhhhhhhhh}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage

\section{Wstęp}
Obliczenia numeryczne dotyczące symulacji płynów odgrywają kluczową rolę we współczesnej inżynierii i naukach techninych. 
Opiera się na nich wiele dziedzin oraz sektorów branżowych takich jak: inżynieria chemiczna, energetyka, lotnictwo, motoryzacja, meteorologia, a także przemysły growy i rozrywkowy. 
Dzięki nim możliwa jest uzyskanie zadawalających rezultatów przewidywania zachowania cieczy bez konieczności przeprowadzania czasochłonnych i skomplikowanych obliczeń 
bądź odwzorowywania układów o dużej złożoności.\newline\newline

Wzrost dokładności modeli fizycznych oraz zapotrzebowań na rozdzielczość i wyprzedzenie dokonywanych obliczeń powoduje wzrost wymaganej mocy obliczeniowej i pamięci. 
Złożoność obliczeniowa problemu symulacji powoduje że istotnym ograniczeniem może być czas jej wykonania. Konsekwentnie wysokiego znaczenia nabierają metody optymalizacji, 
których celem jest ograniczenie wykorzystywanej pamięci oraz czasu koniecznego do przeprowadzenia obliczeń.\newline

\newpage
\section{Cel i zakres}
Celem niniejszej pracy inżynierskiej jest zaproponowanie i analiza rozwiązań dotyczących optymalizacji symulacji płynów. 
Praca koncentruje się na rozwiązaniach dotyczących metod wyszukiwania cząstek sąsiadujących w metodzie cząstek wygładzonych (SPH) opartej o równania Naviera-Stokesa.\newline\newline

Zakres pracy obejmuje omówienie podstaw teoretycznych dotyczących symulacji płynów, zaproponowanie metod optymalizacji i ich analizę teoretyczną, 
oraz przedstawienie wyników zastosowania tychże metod w praktyce. Uzyskane rezultaty mogą stanowić podstawę do dalszych badań na temat optymalizacji 
oraz praktycznego wykorzystania wypracowanych rozwiązań.\newline

\newpage
\section{Wstęp teoretyczny}
\subsection{Równania Naviera-Stokesa}
Równania Naviera–Stokesa stanowią podstawowy zestaw równań opisujących ruch płynów, zarówno cieczy, jak i gazów. 
Ich sformułowanie opiera się na zasadzie zachowania pędu, zgodnie z którą zmiany pędu elementarnej objętości płynu wynikają z oddziaływania sił działających na ten element. 
Równania zakładają że zmiany zależą od sił lepkości, sił wynikających z ciśnienia oraz sił masowe, takich jak siła grawitacji.\newline

Równania zapisane są w postaci równań różniczkowych cząstkowych i do ich rozwiązania niezbędne jest zastosowanie narzędzi rachunku różniczkowego i całkowego. 
Przez wzgląd na swoją nieliniowość oraz sprzężenie pomiędzy składowymi prędkości, ich rozwiązanie stanowi istotne wyzwanie obliczeniowe, co powoduje, 
że uzyskanie rozwiązań drogą analityczną jest realistyczne jedynie w najprostszych przypadkach, takich jak ustalony, laminarny i nieturbulentny przepływ w geometriach prostych.\newline

W przypadkach bardziej złożonych zagadnień, w szczególności przepływów niestacjonarnych, trójwymiarowych lub turbulentnych, 
stosowanych m.in. w obliczeniach aerodynamicznych i inżynierskich, konieczne jest wykorzystanie metod numerycznych. 
Metody te, implementowane w narzędziach obliczeniowej mechaniki płynów (CFD), umożliwiają przybliżone rozwiązanie równań Naviera–Stokesa i analizę rzeczywistych zjawisk przepływowych, 
które nie są możliwe do opisania metodami analitycznymi.\newline

Zapis równań Naviera-Stokesa w kartezjańskim układzie współrzędnych wygląda następująco:

$$ 
\rho 
\frac{du }{dt }
= X 
- \frac{\partial  p }{\partial x }
+ \frac \partial {\partial  x }
\left [ 
    \mu \left ( 
        2 \frac{\partial u }{\partial  x }
        - { \frac{2}{3} }  \mathop{\rm div}  \mathbf w 
    \right )  
\right ] 
+
$$

$$ 
+ 
\frac \partial {\partial  y }
\left [ 
    \mu \left ( 
        \frac{\partial u }{\partial  y }
        + \frac{\partial v }{\partial  x }
    \right )  
\right ]
+ 
\frac \partial {\partial  z }
\left [ 
    \mu \left ( 
        \frac{\partial w }{\partial  x }
        + \frac{\partial u }{\partial  z }
    \right )  
\right ],
$$

$$ 
\rho 
\frac{dv }{dt }
= Y
- \frac{\partial  p }{\partial y }
+ \frac \partial {\partial  y }
\left [ 
    \mu \left ( 
        2 \frac{\partial v }{\partial  y }
        - { \frac{2}{3} }  \mathop{\rm div}  \mathbf w 
    \right )  
\right ] 
+
$$

$$ 
+ 
\frac \partial {\partial  z }
\left [ 
    \mu \left ( 
        \frac{\partial v }{\partial  z }
        + \frac{\partial w }{\partial  y }
    \right )  
\right ]
+ 
\frac \partial {\partial  x }
\left [ 
    \mu \left ( 
        \frac{\partial u }{\partial  y }
        + \frac{\partial v }{\partial  x }
    \right )  
\right ],
$$

$$ 
\rho 
\frac{dw }{dt }
= Z 
- \frac{\partial  p }{\partial z }
+ \frac \partial {\partial  z }
\left [ 
    \mu \left ( 
        2 \frac{\partial w }{\partial  z }
        - { \frac{2}{3} }  \mathop{\rm div}  \mathbf w 
    \right )  
\right ] 
+
$$

$$ 
+ 
\frac \partial {\partial  x }
\left [ 
    \mu \left ( 
        \frac{\partial w }{\partial  x }
        + \frac{\partial u }{\partial  z }
    \right )  
\right ]
+ 
\frac \partial {\partial  y }
\left [ 
    \mu \left ( 
        \frac{\partial v }{\partial  z }
        + \frac{\partial w }{\partial  y }
    \right )  
\right ],
$$

$$ 
\frac{\partial \rho }{\partial t}
+ \frac{\partial (\rho u) }{\partial x}
+ \frac{\partial (\rho v) }{\partial y}
+ \frac{\partial (\rho w) }{\partial z}
= 0,
$$

gdzie:\newline
w - wektor prędkości o rzutach u, v, w na osie współrzędnych x, y, z,\newline
p - ciśnienie,\newline
$\rho$ - gęstość,\newline
$\mu$ - współczynnik lepkości,\newline
X,Y,Z - rzuty wektora sił masowych K na osie współrzędnych,\newline
(pochodna substancjonalna) - pochodna substancjonalna,\newline

Równania są wyprowadzone na podstawie Newtonowskiego uogólnionego prawa tarcia.
Analiza płynów ściśliwych wymaga dodatkowo zastosowania równań uwzględniających ciśnienie, gęstość, temperaturę i przepływy energii.
Dla nieściśliwych izotermicznych płynów, równania przyjmują następującą formę:\newline
$$
\rho \frac {dw}{dt}
= \boldsymbol{K} - grad \space \rho
+ \mu \Delta \boldsymbol{w},
$$
$$
div \space \boldsymbol{w} = 0.
$$


\subsection{Metoda cząsteczkowa symulacji}
\subsubsection{Równania Naviera-Stokesa}
Przyjmijmy następującą formę równań dla cieczy nieściśliwych:\newline
$$
\rho \left (
    \frac{\partial v}{\partial t} + v \nabla v
\right )
= - \nabla p + \rho f_{zew} + \mu \nabla^2v,
$$
$$
\frac{\partial \rho}{\partial t} + \nabla(\rho v) = 0
$$

Wykorzystanie metody cząsteczkowej pozwala na pewne uproszczenia, mianowicie:\newline
(1) Stała liczba cząsteczek zapewnia zachowanie masy wewnątrz systemu\newline
(2) wyrażenie (wstaw wyrażenie) może zostać zastąpione operatorem Stokesa(wstaw drugie). 
Ponieważ cząstki poruszają się wraz z płynem operator Stokesa pola prędkości jest pochodną czasu prędkości co znaczy, że wyrażenie $v \nabla v$ nie jest potrzebne.\newline
Oznacza to że równanie przyjmuje następującą formę:\newline
$$
\rho \frac{D v}{D t}
= - \nabla p + \rho f_{zew} + \mu \nabla^2v,
$$
Prawa strona równania składa się z trzech składowych:\newline
$- \nabla p$- odwrotność gradientu ciśnienia\newline
Odpowiada za siły wynikające z miejscowych różnic w ciśnieniu wewnątrz płynu.\newline
Współczynnik ten odpowiada za ruch miejscowy płynu podyktowany gradientem ciśnienia, powodując dążenie do wyrównania ciśnienia w ośrodku.\newline
$\rho f_{zew}$ - siły zewnętrzne\newline
Odpowiadają siłom jednorodnym w symulowanej przestrzeni. Dotyczą one sił zewnętrznych jak grawitacja, a w przypadku symulacji objętości płynów poddawanych innym przyśpieszeniom wynikającym na przykład z ruchu ośrodka, również takowym.\newline
Ponieważ zastosowana wersja symulacji nie zakłada sił innych niż siła grawitacji równanie wygląda następująco:\newline
$$
\rho \frac{D v}{D t}
= - \nabla p + \rho g + \mu \nabla^2v,
$$
$\mu \nabla^2v$ - siły lepkości\newline
Siły powodujące wygładzenie pola prędkości płynu spowodowane jego lepkością.\newline


\subsubsection{Metoda cząstek wygładzonych}
Metoda cząstek wygładzonych (ang. Smoothed Particle Hydrophysics - SPH) to bezsiatkowa metoda numeryczna stosowana do symulacji przepływów płynów i innych zjawisk ciągłych. Pierwotnie opracowana do symulacji zjawisk astrofizycznych aktualnie znajduje zastsowanie m.in. w mechanice płynów, inżynierii materiałowej, czy grafice komputerowej. Brak zastosowania siatki obliczeniowej jest dużą zaletą tej metody, pozwalającą na modelowanie znacznych deformacji, swobodnych powierzchni i zjawisk nieciągłych.\newline\newline
W metodzie tej ośrodek ciągły jest reprezentowany jako zbiór dyskretnych cząstek, które zawierają informację o lokalnych wartościach pól takich jak masa, gęstość, prędkość itp. Każda z cząstek oddziałowuje jedynie z cząstkami które znajdują się w jej bezpośrednim sąsiedztwie określonym przez promień wygładzania $h$. Wartości pól w danym punkcie przestrzeni są aproksymowane za pomocą funkcji wygładzającej, która dyktuje wagę z jaką uwzględniany jest wkład cząstek sąsiadujących w zależności od odległości.\newline\newline
Podstawą metody jest przybliżenie całki opisującej wielkość fizyczną w postaci sumy po cząstkach:\newline
$$
A(r) \approx \sum_{j}A_j \frac{m_j}{\rho_j}W(r-r_j,h),
$$
Gdzie:\newline
A - dowolna wielkość fizyczna,\newline
m - masa cząstki,\newline
$\rho$ - gęstość w punkcie cząstki,\newline
W - funkcja wygładzająca\newline
r - odległość od cząstki,\newline
h - odległość oddziaływania,\newline\newline
Równania opisujące zmiany stanu cząstek, takie jak równania Naviera-Stokesa są w metodzie SPH zapisywane w postaci dyskretnej, 
w oparciu o tą właśnie metodę obliczania wartości fizycznej w punkcie.\newline
Do zalet metody SPH należy prostota jej implementacji, łatwość zrównoleglenia oraz możliwość modelowania zjawisk z ruchomymi granicami.\newline
Głównymi wadami są natomiast wysoka złożoność obliczeniowa spowodowana koniecznością wyszukiwania cząstek sąsiadujących 
i problemy wynikające z trudności zachowania stabilności numerycznej oraz możliwa niska dokładność przy nieodpowiednich parametrach.\newline
Dlatego też metoda SPH wymaga zastosowania technik optymalizacyjnych i doboru odpowiednich parametrów symulacji.\newline


\subsubsection{Ciśnienie}
Zastosowanie metody SPH dla ciśnienia opisanego jako wyrażenie $- \nabla p$:
$$
f_i = -\sum_j m_j \frac{p_j}{\rho_j}\nabla W(r_i - r_j, h),
$$
Wstępna analiza równania pozwala zauważyć, że dla dwóch oddziałujących cząstek siła ta nie jest symetryczna. 
Jest to spowodowane możliwością wystąpienia różnicy ciśnień w miejscach dwóch cząstek. Istnieje wiele metod wyrównania tych sił. 
Jedną z nich jest proste uśrednienie wartości ciśnienia tychże cząstek:\newline
$$
f_i = -\sum_j m_j \frac{p_j + p_i}{2\rho_j}\nabla W(r_i - r_j, h),
$$
Ciśnienie p wyznaczane jest równaniem gazu idealnego:\newline
$$
p=k\rho
$$
gdzie k to stała gazu zależna od temperatury.\newline
Desburn sugeruje wykorzystanie zmodyfikowanej wersji równania:\newline
$$
p=k(\rho - \rho_0)
$$
gdzie $\rho_0$ jest gęstością spoczynku.\newline
Pozwala to na wyznaczenie gęstości do której dążyć będzie symulowany płyn jako łatwo modyfikowalny parametr.\newline
Ponieważ równania zależą od gradientu ciśnienia, przesunięcie nie wpływa na obliczenia siły.\newline

Postać kodowa równania ciśnienia z uwzględnieniem symetryzacji sił wygląda następująco:\newline
\begin{algorithm}
\caption{Obliczenia ciśnienia}
\begin{algorithmic}[1]
void CalculatePressureForce(uint3 id : SV_DispatchThreadID)\\
{\\
	if (id.x >= numParticles)\\
		return;\\
\\
	float density = Densities[id.x][0];\\
	float densityNear = Densities[id.x][1];\\
	float pressure = PressureFromDensity(density);\\
	float nearPressure = NearPressureFromDensity(densityNear);\\
	float2 pressureForce = 0;\\
	\\
	float2 position = PredictedPositions[id.x];\\
	float sqrSmoothingRadius = smoothingRadius * smoothingRadius;\\
\\
	for (uint secondParticleIndex = 0; secondParticleIndex < numParticles; secondParticleIndex++)\\
	{\\
			if (secondParticleIndex == id.x)\\
				continue;\\
\\
			float2 secondParticlePosition = PredictedPositions[secondParticleIndex];\\
			float2 vectorToSecondParticle = secondParticlePosition - position;\\
			float sqrDstToSecondParticle = dot(vectorToSecondParticle, vectorToSecondParticle);\\
\\
			if (sqrDstToSecondParticle > sqrSmoothingRadius)\\
				continue;\\
\\
			float distanceToSecondParticle = sqrt(sqrDstToSecondParticle);\\
			float2 interractionDirection = distanceToSecondParticle > 0 ? vectorToSecondParticle / distanceToSecondParticle : float2(0, 1);\\
\\
			float secondParticlePressure = PressureFromDensity(Densities[secondParticleIndex][0]);\\
			float secondParticleNearPressure = NearPressureFromDensity(Densities[secondParticleIndex][1]);\\
\\
			float sharedPressure = (pressure + secondParticlePressure) * 0.5;\\
			float sharedNearPressure = (nearPressure + secondParticleNearPressure) * 0.5;\\
\\
			pressureForce += interractionDirection * DensityDerivative(distanceToSecondParticle, smoothingRadius) * sharedPressure / Densities[secondParticleIndex][0];\\
			pressureForce += interractionDirection * NearDensityDerivative(distanceToSecondParticle, smoothingRadius) * sharedNearPressure / Densities[secondParticleIndex][1];\\
	}\\
	float2 acceleration = pressureForce / density;\\
	Velocities[id.x] += acceleration * timeStep;\\
}\\
\end{algorithmic}
\end{algorithm}

\subsubsection{Siły zewnętrzne}
Obliczenia dla siły grawitacji ograniczają się do prostego równania:\newline
$$
f_i = g
$$

W kodzie:\newline
\begin{algorithm}
\caption{Obliczenia siły grawitacji}
\begin{algorithmic}[1]
void CalculateExternalForces(uint3 id : SV_DispatchThreadID)\\
{\\
	if (id.x >= numParticles)\\
		return;\\
\\
	Velocities[id.x] += ExternalForces(Positions[id.x], Velocities[id.x]) * timeStep;\\
}\\
\\
float2 ExternalForces(float2 pos, float2 velocity)\\
{\\
	// Gravity\\
	return float2(0, gravity);\\
}\\
\end{algorithmic}
\end{algorithm}
Wyrażenie dla lepkości $\mu \nabla^2v$ przekształcone do sumy:\newline
$$
f_i = \mu\sum_j m_j \frac{v_j}{\rho_j}\nabla^2W(r_i-r_j,h)
$$
Jak widać również skutkuje siłami asymetrycznymi. Ponieważ siły te operują na różnicach prędkości, naturalnym jest usymetryzowanie ich na różnicach prędkości:\newline
$$
f_i = \mu\sum_j m_j \frac{v_j-v_i}{\rho_j}\nabla^2W(r_i-r_j,h)
$$

Kod:\newline
\begin{algorithm}
\caption{Obliczenia lepkości}
\begin{algorithmic}[1]
	void CalculateViscosity(uint3 id : SV_DispatchThreadID)\\
{\\
	if (id.x >= numParticles)\\
		return;\\
	\\
	float2 position = PredictedPositions[id.x];\\
	float sqrSmoothingRadius = smoothingRadius * smoothingRadius;\\
\\
	float2 viscosityForce = 0;\\
	float2 velocity = Velocities[id.x];\\
\\
	for (uint secondParticleIndex = 0; secondParticleIndex < numParticles; secondParticleIndex++)\\
	{\\
			if (secondParticleIndex == id.x)\\
				continue;\\
\\
			float2 secondParticlePosition = PredictedPositions[secondParticleIndex];\\
			float2 vectorToSecondParticle = secondParticlePosition - position;\\
			float sqrDstToSecondParticle = dot(vectorToSecondParticle, vectorToSecondParticle);\\
\\
			if (sqrDstToSecondParticle > sqrSmoothingRadius)\\
				continue;\\
\\
			float distanceToSecondParticle = sqrt(sqrDstToSecondParticle);\\
			float2 secondParticleVelocity = Velocities[secondParticleIndex];\\
			viscosityForce += (secondParticleVelocity - velocity) * ViscosityKernel(distanceToSecondParticle, smoothingRadius);\\
	}\\
	Velocities[id.x] += viscosityForce * viscosityStrength * timeStep;\\
}\\
\end{algorithmic}
\end{algorithm}

\subsubsection{Bliska gęstość}
W celu poprawy stabilności symulacji stosuje się dodatkowe wyrażenie odpowiadające za bliską gęstość cząstek. 
Jego celem jest zapobieganie zbyt dużemu zbliżaniu się cząstek do siebie.\newline
Wyrażenie to ma postać:\newline
$$
f_i = -k_{near}\sum_j m_j \frac{1}{\rho_j}\nabla W(r_i - r_j, h),
$$
Gdzie $k_{near}$ to współczynnik siły bliskiej gęstości.\newline
Bliska gęstość pozwala na uzyskanie bardziej realistycznego zachowania płynu poprzez zapobieganie nadmiernemu zagęszczeniu cząstek, 
co powoduje przybliżenie zachowania symulacji do płynów niesprężystych.\newline

[tu wstaw kod bliskiej gęstości]\newline

\subsubsection{Przewidywanie pozycji}
Techniką stabilizacji symulacji jest przewidywanie pozycji cząstek w następnym kroku na podstawie ich aktualnego położenia i prędkości.\newline
Oznacza to że w każdym kroku do obliczeń zmiany prędkości cząstki wykorzystujemy nie pozycję aktualną cząstki lecz pozycję przewidzianą.\newline
Oznacza to że podstawowe równanie metody sph zostaje zmodyfikowane do następującej postaci:\newline
$$
A(r) \approx \sum_{j}A_j \frac{m_j}{\rho_j}W(r-r_j,h),
$$

\subsubsection{Funkcje wygładzania}
Metoda wygładzonych cząstek opiera się na funkcjach wygładzania. Są to funkcje określające wzajemny wpływ cząstek w zależności od odległości.\newline
Funkcje wygładzania można traktować jako funkcje jednej zmiennej 
$$
W(r) = 
\begin{cases}
f(r,h), & dla \space r<h,\\
0,    & dla \space r>=h
\end{cases}
$$
gdzie:\newline
r - odległość analizowanej cząstki od cząstki sąsiadującej\newline
h - maksymalna odległość interakcji\newline
f - funkcja kształtu krzywej\newline
Jest to forma zakładająca stałą maksymalną odległość interakcji, co powoduje ograniczenia w dowolności konfiguracji symulacji.\newline
Alternatywną i zazwyczaj stosowaną formą jest wyrażenie funkcji wygładzania jako funkcji dwóch zmiennych:\newline
$$
W(r,h) = 
\begin{cases}
m(h)f(r,h), & dla \space r<h,\\
0,    & dla \space r>=h
\end{cases}
$$
Gdzie m to funkcja maksymalnej odległości interakcji, która służy jako współczynnik standaryzujący. Jej celem jest zachowanie stałej wartości całki funkcj wygładzającej. 
W przypadku jej niezastosowania zwiększenie odległości interakcji celem wygładzenia wartości pola spowoduje gwałtowny wzrost wartości. 
Istnienie współczynnika pozwala na swobodniejszą manipulację odległością interakcji, bez niepożądanych zachowań.\newline
Funkcja m jest określona poniższym wzorem:\newline
$$
\frac {\pi h \int_0^h{f(r,h)}}{m(h)} = const
$$

Dodatkowo w metodzie SPH wykorzystujemy pochodne funkcj wygładzających $\frac {dW(r,h)}{dr}$ celem wyznaczenia gradientów pól cech fizycznych.\newline

\section{Metody odnajdywania cząstek}
\subsection{Odnajdywanie siłowe}
Najprostszym sposobem odnajdywania cząstek sąsiadujących jest użycie metody siłowej (eng. brute-force). 
Metoda polega na przeszukaniu zbioru cząstek i sprawdzenia odległości od cząstki aktualnie analizowanej.\newline
Oznacza to że dla każdej możliwej pary cząstek konieczne jest wykonanie prównania odległości z maksymalną odległością interakcji:\newline
$$
||r_i-r_j|| \leq h.
$$

Jeśli warunek zostanie spełniony to znaczy, że cząstka j jest w sąsiedztwie czątki i i zostaje uwzględniona w dalszych obliczeniach.\newline

Postać algorytmiczna wyszukiwania metodą siłową:\newline

\begin{algorithm}
\caption{Metoda siłowa}
\begin{algorithmic}[1]
void CalculateViscosity(uint3 id : SV_DispatchThreadID)\\
{\\
	if (id.x >= numParticles)\\
		return;\\
        for (uint secondParticleIndex = 0;\\ secondParticleIndex < numParticles; secondParticleIndex++)\\
	{\\
			if (secondParticleIndex == id.x)\\
				continue;\\
			if (sqrDstToSecondParticle > sqrSmoothingRadius)\\
				continue;\\
            wykonaj_obliczenia();\\
    }\\
}
\end{algorithmic}
\end{algorithm}


Złożoność obliczeniowa metody siłowej odnajdywania czątek wynosi $O(N^2)$, co oznacza kwadratowy wzrost liczby operacji w stosunku do liczby cząstek.\newline
Metoda ta jest łatwa w implementacji oraz nie wymaga dodatkowych struktur, przez co może zostać wykorzystana w stosunkowo niewielkich symulacjach służących do demonstracji lub nauki.\newline
W zastosowaniach praktycznych metody SPH, gdzie liczba cząstek sięga tysiący, bądź milionów, siłowe odnajdywanie jest niewystarczające przez wzgląd na znaczący czas obliczeń.\newline


\subsection{Siatka jednorodna}
Jednym z rozwiązań mających na celu przyśpieszenie procesu wyszukiwania cząstek sąsiadujących jest zastosowanie siatki jednorodnej (eng. uniform grid).\newline
Metoda ta polega na podziale przestrzeni na regularne komórki o stałym rozmiarze. 
Rozmiar komórki dostosowywany jest do odległości interakcji h. 
Uzależnienie to pozwala ustalić stałą, ograniczoną liczbę komórek które należy przeszukać.\newline


Każdej cząstce przypisywana jest komórka siatki na podstawie jej pozycji:\newline
$$
i_n = \frac {x_n} r
$$
Gdzie:\newline
$i_n$ - indeks cząstki w wymiarze $n$\newline
$x_n$ - położenie cząstki wzdłuż osi $n$\newline
$r$ - wielkość komórki siatki\newline\newline
Na podstawie danego wzoru algorytm przypisywania komórki wygląda następująco:\newline
[algorytm przypisywania komórki]\newline
W takim przypadku liczba operacji koniecznych do stworzenia struktury wynosi:\newline
[wzór na liczbę operacji]\newline
Najczęściej wartość r jest równa, lub nieznacznie większa od odległości interakcji co ogranicza ilość koniecznycj do sprawdzenia komórek wzorem:\newline
$$
n_s = 3^d
$$
Gdzie:\newline
$n_s$ - liczba komórek koniecznych do sprawdzenia\newline
$d$ - liczba wymiarów symulacji\newline

Zastosowanie siatki pozwala uzależnić złożoność obliczeniową algorytmu od liczby cząstek oczekiwanej wewnątrz sąsiadujących komórek siatki, zamiast od całkowitej liczby cząstek.\newline

\begin{algorithm}
\caption{Wykorzystanie siatki}
\begin{algorithmic}[1]
\end{algorithmic}
\end{algorithm}

\subsection{Haszowanie przestrzenne}
Haszowanie przestrzenne (ang. spatial hashing) to technika optymalizacji wyszukiwania cząstek sąsiadujących, która stanowi rozwinięcie podejścia opartego na siatce jednorodnej.
Metoda ta pozwala na odwzorowanie komórek siatki na strukturę o stałym lub ograniczonym rozmiarze, co skutkuje redukcją zużytej pamięci oraz poprawą skalowalności algorytmu.\newline
Podobnie do przypadku siatki jednorodnej, przestrzeń symulacji dzielona jest na komórki o stałym rozmiarze uzależnionym od odległości interakcji. 
Każdej cząstce przypisywany jest indeks komórki na podstawie jej położenia. 
Jednak zamiast przechowywania pełnowymiarowej tablicy komórek, indeks komórki jest przekształcany za pomocą funkcji haszującej do jednowymiarowego klucza, 
który służy identyfikacji miejsca przechowywania cząstki w tablicy haszującej.\newline
Standardowa funkcja mieszająca posiada następującą postać:\newline
$$
h(x_0,x_1,...,x_i) = (x_0*p_0\oplus x_1*p_1 \oplus ... \oplus x_i*p_i) mod \space M,
$$
Gdzie:\newline
$x_n$ - współrzędna komórki w wymiarze $n$,\newline
$p_n$ - stały współczynnik dla wymiaru $n$,\newline
$M$ - rozmiar tablicy mieszającej.\newline
Metoda ta jest szczególnie korzystna w przypadku dużych, dynamicznych scen, w których obszar symulacji jest rozległy, a cząstki zajmują jedynie jego część. 
Dzięki temu unika się alokowania pamięci dla pustych komórek, co stanowi istotną przewagę nad klasyczną siatką jednorodną.\newline
Do głównych zalet haszowania przestrzennego należą oszczędność pamięci, wysoka wydajność oraz dobra adaptowalność do implementacji równoległych, w tym na procesorach graficznych. 
Wśród wad można wymienić konieczność obsługi kolizji w tablicy haszującej oraz większą złożoność implementacyjną w porównaniu do klasycznej siatki jednorodnej.\newline
Możliwą do zastosowania optymalizacją jest wykorzystanie tablicy skrótów. 
Metoda ta polega na pierwotnym przypisaniu każdej cząsteczce wartości odpowiadającej kluczowi komórki w której się znajduje. 
Następnym krokiem jest posortowanie cząstek według tych właśnie kluczy. Tablica posortowanych cząstek umożliwia na utworzenie tablicy szybkiego dostępu.\newline
Tablica ta jest rozmiaru maksymalnego klucza. Każda komórka tablicy zawiera indeks pierwszej cząstki w tablicy posortowanych cząstek, 
której przypisany klucz odpowiada indeksowi danej komórki.\newline

[rysunek tablicy]\newline

Zakładając stałą ilość komórek symulacji i wielkość tablicy mieszającej można wyprowadzić zależność:\newline
$$
P_{dup} = 1-(1-\frac 1 M)^{N-1} 
$$
Gdzie:\newline
$P_{dup}$ - prawdopodobieństwo duplikatu klucza dla pojedynczej komórki,\newline
$N$ - liczba komórek siatki.\newline

\subsection{Stały indeks}
Pewną metodą optymalizacji jest wykorzystanie indeksów bez kolizji wyliczanych na podstawie pozycji komórki w siatce. Można zaproponować następujący wzór na indeks komórki:\newline
$$
h(x_0,x_1,...,x_i) = (x_0 + x_1*m_0 + ... + x_i*m_i*m_{i-1}*...*m_0),
$$
Gdzie:\newline
$m_n$ - maksymalna liczba komórek w osi $n$\newline

Optymalizacja ta wymaga odgórnej stałej wielkości tablicy mieszającej, równej liczbie komórek siatki przestrzennej.\newline
Postać oblczenia indeksu w kodzie:\newline
[algorithm]\newline

\section{Implementacja symulacji}
W ramach pracy udało się zaimplementować symulację z użyciem metody sph.\newline
Symulacja w środowisku unity pozwala na manipulowanie parametrami poprzez edytor parametrów unity.\newline
Symulacja w pełni wspiera manipulację parametrami:\newline
*Liczba cząstek*
*Grawiracja*
*Krok czasowy*
*Siła sprężystości pojemnika*
*Promień wygładzania*
*Gęstość docelowa*
*Mnożnik ciśnienia*
*Mnożnik bliskiego ciśnienia*
*Siła lepkości*
*Granice symulacji*
[mnóstwo screenów z róznymi parametrami]

Z powodu implementacji symulacji przy użyciu porocesora graficznego, została ona podzielona na etapy zapisane w odpowiednich jądrach.\newline\
\subsection{Jądro sił zewnętrznych}
\begin{verbatim}
[numthreads(NumThreads, 1, 1)]
void CalculateExternalForces(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles)
		return;

	Velocities[id.x] += ExternalForces(Positions[id.x], Velocities[id.x]) * timeStep;
}
\end{verbatim}
Ciało funkcji ExternalForces():\newline
\begin{verbatim}
float2 ExternalForces(float2 pos, float2 velocity)
{
	return float2(0, gravity);
}
\end{verbatim}
Jądro jest odpowiedzialne za nadanie każdej cząsteczce przyśpieszenie związanego z siłami zewnętrznymi, co w naszym przypadku oznacza tylko siłę grawitacji.\newline

\subsection{Jądro przewidywania pozycji cząstki}
\begin{verbatim}
void PredictPositions(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles)
		return;

	const float predictionStep = 1 / 120.0;
	PredictedPositions[id.x] = Positions[id.x] + Velocities[id.x] * predictionStep;
}
\end{verbatim}
Na podstawie aktualnej pozycji i prędkości obliczana jest pozycja cząstki, która posłyży do obliczeń sił wpływających na tę cząstkę.\newline

\subsection{Jądro gęstości}
\begin{verbatim}
[numthreads(NumThreads, 1, 1)]
void CalculateDensities(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles)
		return;

	float2 position = PredictedPositions[id.x];
	Densities[id.x] = CalculateDensity(position);
}
\end{verbatim}

Ciało funkcji CalculateDensity():\newline
\begin{verbatim}
float2 CalculateDensity(float2 position)
{
	float sqrSmoothingRadius = smoothingRadius * smoothingRadius;
	float density = 0;
	float nearDensity = 0;

	for (int secondParticleIndex = 0; secondParticleIndex < numParticles; secondParticleIndex++)
	{
			float2 secondParticlePosition = PredictedPositions[secondParticleIndex];
			float2 vectorToSecondParticle = secondParticlePosition - position;
			float sqrDstToSecondParticle = dot(vectorToSecondParticle, vectorToSecondParticle);

			if (sqrDstToSecondParticle > sqrSmoothingRadius)
				continue;

			float dst = sqrt(sqrDstToSecondParticle);
			density += DensityKernel(dst, smoothingRadius);
			nearDensity += NearDensityKernel(dst, smoothingRadius);
	}

	return float2(density, nearDensity);
}
\end{verbatim}

\subsection{Jądro sił ciśnienia}
\begin{verbatim}
[numthreads(NumThreads, 1, 1)]
void CalculatePressureForce(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles)
		return;

	float density = Densities[id.x][0];
	float densityNear = Densities[id.x][1];
	float pressure = PressureFromDensity(density);
	float nearPressure = NearPressureFromDensity(densityNear);
	float2 pressureForce = 0;
	
	float2 position = PredictedPositions[id.x];
	float sqrSmoothingRadius = smoothingRadius * smoothingRadius;

	for (uint secondParticleIndex = 0; secondParticleIndex < numParticles; secondParticleIndex++)
	{
			if (secondParticleIndex == id.x)
				continue;

			float2 secondParticlePosition = PredictedPositions[secondParticleIndex];
			float2 vectorToSecondParticle = secondParticlePosition - position;
			float sqrDstToSecondParticle = dot(vectorToSecondParticle, vectorToSecondParticle);

			if (sqrDstToSecondParticle > sqrSmoothingRadius)
				continue;

			float distanceToSecondParticle = sqrt(sqrDstToSecondParticle);
			float2 interractionDirection = distanceToSecondParticle > 0 ? vectorToSecondParticle / distanceToSecondParticle : float2(0, 1);

			float secondParticlePressure = PressureFromDensity(Densities[secondParticleIndex][0]);
			float secondParticleNearPressure = NearPressureFromDensity(Densities[secondParticleIndex][1]);

			float sharedPressure = (pressure + secondParticlePressure) * 0.5;
			float sharedNearPressure = (nearPressure + secondParticleNearPressure) * 0.5;

			pressureForce += interractionDirection * DensityDerivative(distanceToSecondParticle, smoothingRadius) * sharedPressure / Densities[secondParticleIndex][0];
			pressureForce += interractionDirection * NearDensityDerivative(distanceToSecondParticle, smoothingRadius) * sharedNearPressure / Densities[secondParticleIndex][1];
	}
	float2 acceleration = pressureForce / density;
	Velocities[id.x] += acceleration * timeStep;
}
\end{verbatim}

\subsection{Jądro sił lepkości}
\begin{verbatim}
[numthreads(NumThreads, 1, 1)]
void CalculateViscosity(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles)
		return;
	
	float2 position = PredictedPositions[id.x];
	float sqrSmoothingRadius = smoothingRadius * smoothingRadius;

	float2 viscosityForce = 0;
	float2 velocity = Velocities[id.x];

	for (uint secondParticleIndex = 0; secondParticleIndex < numParticles; secondParticleIndex++)
	{
			if (secondParticleIndex == id.x)
				continue;

			float2 secondParticlePosition = PredictedPositions[secondParticleIndex];
			float2 vectorToSecondParticle = secondParticlePosition - position;
			float sqrDstToSecondParticle = dot(vectorToSecondParticle, vectorToSecondParticle);

			if (sqrDstToSecondParticle > sqrSmoothingRadius)
				continue;

			float distanceToSecondParticle = sqrt(sqrDstToSecondParticle);
			float2 secondParticleVelocity = Velocities[secondParticleIndex];
			viscosityForce += (secondParticleVelocity - velocity) * ViscosityKernel(distanceToSecondParticle, smoothingRadius);
	}
	Velocities[id.x] += viscosityForce * viscosityStrength * timeStep;
}
\end{verbatim}
\subsection{Jądro aktualizacji pozycji}
\begin{verbatim}
[numthreads(NumThreads, 1, 1)]
void UpdatePositions(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles)
		return;

	Positions[id.x] += Velocities[id.x] * timeStep;
	HandleCollisions(id.x);
}
\end{verbatim}


\subsection{Funkcje wygładzające}
W wyniku badań empirycznych w implementacji symulacji został zastosowany szereg wybranych funkcji wygładzających.\newline
\subsubsection{Funkcja wielomianowa szóstego stopnia}
$$
W(r,h) = m(h)
\begin{cases}
(h^2-r^2)^3, & dla \space 0 \leq r \leq h\\
0, & dla \space r > h
\end{cases}
$$

\begin{center}
\begin{tikzpicture}% y=x^2
[baseline=(current bounding box.north)]
\begin{axis}[
    axis equal,
    width=4in,
    height=4in,
    axis lines=middle,
    axis line style={very thick},
    grid style={thin,densely dotted,black!50},
    grid=major,
    xticklabels={},
    yticklabels={},
    xtick distance=1, ytick distance=1,
    extra x ticks=2, extra y ticks=4,
    xmin=-1, xmax=1,
    ymin=-0.2, ymax=1.5,
    xlabel=$x$,
    ylabel=$y$]
    \addplot[
    <->,
    domain=-2:2,
    samples=500]
        (x,{(1-x^2)^3});
\end{axis}
\end{tikzpicture}
\end{center}
\newline
Gdzie $m(h)$ wynikające z normalizacji:

$$
m(h) = \frac{35}{16\pi h^8}
$$
\newline
Co w postaci algorytmicznej wygląda następująco:\newline

\begin{verbatim}
float Poly6Kernel(float distance, float radius)
{
	if (distance >= radius)
		return 0;
	float v = radius * radius - distance * distance;
	return v * v * v * Poly6ScalingFactor;
}
\end{verbatim}

Funkcja wielomianowa służy do obliczeń dotyczących lepkości. Ponieważ nie wykorzystujemy gradientu lepkości, możemy pozwolić na wykorzystanie funkcji o niskim gradiencie w okolicach wartości $x=0$. Zapewnia to bardziej łagodną granicę wygładzania ruchu cząstek.\newline

\subsubsection{Funkcja "ostra" drugiego stopnia}
$$
W(r,h) = m(h)
\begin{cases}
(h-r)^2, & dla \space 0 \leq r \leq h\\
0, & dla \space r > h
\end{cases}
$$

\begin{center}
\begin{tikzpicture}% y=x^2
[baseline=(current bounding box.north)]
\begin{axis}[
    axis equal,
    width=4in,
    height=4in,
    axis lines=middle,
    axis line style={very thick},
    grid style={thin,densely dotted,black!50},
    grid=major,
    xticklabels={},
    yticklabels={},
    xtick distance=1, ytick distance=1,
    extra x ticks=2, extra y ticks=4,
    xmin=-1, xmax=1,
    ymin=-0.2, ymax=1.5,
    xlabel=$x$,
    ylabel=$y$]
    \addplot[
    <->,
    domain=-2:2,
    samples=500]
        (x,{(1-abs(x))^2});
\end{axis}
\end{tikzpicture}
\end{center}
\newline
Gdzie $m(h)$ wynikające z normalizacji:

$$
m(h) = \frac{3}{\pi h^4}
$$
\newline
Co w postaci algorytmicznej wygląda następująco:\newline

\begin{verbatim}
float Pow2Kernel(float distance, float radius)
{
	if (distance >= radius)
        return 0;
	float v = radius - distance;
	return v * v * SpikyPow2ScalingFactor;
}
\end{verbatim}
Funkcja została wykorzystana w obliczeniach gęstości przez wzgląd na wysoki gradient w okolicach początku układu współrzędnych.\newline

\subsubsection{Gradient funkcji drugiego stopnia}
$$
W(r,h) = m(h)
\begin{cases}
(r-h), & dla \space 0 \leq r \leq h\\
0, & dla \space r > h
\end{cases}
$$


\begin{center}
\begin{tikzpicture}% y=x^2
[baseline=(current bounding box.north)]
\begin{axis}[
    axis equal,
    width=4in,
    height=4in,
    axis lines=middle,
    axis line style={very thick},
    grid style={thin,densely dotted,black!50},
    grid=major,
    xticklabels={},
    yticklabels={},
    xtick distance=1, ytick distance=1,
    extra x ticks=2, extra y ticks=4,
    xmin=-1, xmax=1,
    ymin=-1.5, ymax=0.2,
    xlabel=$x$,
    ylabel=$y$]
    \addplot[
    <->,
    domain=-2:2,
    samples=500]
        (x,{(abs(x)-1)});
\end{axis}
\end{tikzpicture}
\end{center}
\newline
Gdzie $m(h)$ wynikające z normalizacji:

$$
m(h) = \frac{-2}{\pi h^3}
$$
\newline
Co w postaci algorytmicznej wygląda następująco:\newline

\begin{verbatim}
float Pow2KernelGradient(float distance, float radius)
{
	if (distance > radius)
        return 0;
	float v = radius - distance;
	return -v * SpikyPow2DerivativeScalingFactor;
}
\end{verbatim}
Funkcja ta służy do obliczeń z wykorzystaniem gradientu gęstości.\newline

\subsubsection{Funkcja "ostra" trzeciego stopnia}
$$
W(r,h) = m(h)
\begin{cases}
(h-r)^3, & dla \space 0 \leq r \leq h\\
0, & dla \space r > h
\end{cases}
$$

\begin{center}
\begin{tikzpicture}% y=x^2
[baseline=(current bounding box.north)]
\begin{axis}[
    axis equal,
    width=4in,
    height=4in,
    axis lines=middle,
    axis line style={very thick},
    grid style={thin,densely dotted,black!50},
    grid=major,
    xticklabels={},
    yticklabels={},
    xtick distance=1, ytick distance=1,
    extra x ticks=2, extra y ticks=4,
    xmin=-1, xmax=1,
    ymin=-0.2, ymax=1.5,
    xlabel=$x$,
    ylabel=$y$]
    \addplot[
    <->,
    domain=-2:2,
    samples=500]
        (x,{(1-abs(x))^3});
\end{axis}
\end{tikzpicture}
\end{center}
\newline
Gdzie $m(h)$ wynikające z normalizacji:

$$
m(h) = \frac{4}{\pi h^5}
$$
\newline
Co w postaci algorytmicznej wygląda następująco:\newline

\begin{verbatim}
float Pow3Kernel(float distance, float radius)
{
	if (distance >= radius)
        return 0;
	float v = radius - distance;
	return v * v * v * SpikyPow3ScalingFactor;
}
\end{verbatim}
Funkcja trzeciego stopnia przez zwiększony gradient w okolicach zera służy do symulacji bliskiej gęstości, która zakłada większą siłę w okolicach cząstki.\newline

\subsubsection{Gradient funkcji trzeciego stopnia}
$$
W(r,h) = m(h)
\begin{cases}
-(h-r)^2, & dla \space 0 \leq r \leq h\\
0, & dla \space r > h
\end{cases}
$$

\begin{center}
\begin{tikzpicture}
[baseline=(current bounding box.north)]
\begin{axis}[
    axis equal,
    width=4in,
    height=4in,
    axis lines=middle,
    axis line style={very thick},
    grid style={thin,densely dotted,black!50},
    grid=major,
    xticklabels={},
    yticklabels={},
    xtick distance=1, ytick distance=1,
    extra x ticks=2, extra y ticks=4,
    xmin=-1, xmax=1,
    ymin=-1.2, ymax=0.2,
    xlabel=$x$,
    ylabel=$y$]
    \addplot[
    <->,
    domain=-2:2,
    samples=500]
        (x,{-(1-abs(x))^2});
\end{axis}
\end{tikzpicture}
\end{center}

\newline
Gdzie $m(h)$ wynikające z normalizacji:

$$
m(h) = \frac{3}{\pi h^4}
$$
\newline
Co w postaci algorytmicznej wygląda następująco:\newline

\begin{verbatim}
float Pow3KernelGradient(float distance, float radius)
{
	if (distance > radius)
        return 0;
	float v = radius - distance;
	return -v * v * SpikyPow3DerivativeScalingFactor;
}
\end{verbatim}
Funkcja ta służy do obliczeń związanych z gradientem bliskiej gęstości.\newline

\subsection{Tablice mieszające}
Zastosowanie tablic mieszających wymaga pewnej modyfikacji kodu zarówno w jądrach jak i po stronie C#.\newline
Pierwszą zmianą jest konieczność dodatkowego obliczania skrótu komórki w której znajduje się cząsteczka wewnątrz jądra przewidywania pozycji.\newline

\begin{verbatim}
[numthreads(NumThreads, 1, 1)]
void PredictPositions(uint3 id : SV_DispatchThreadID)
{
	...
	
	int2 cellIndex = int2(floor(PredictedPositions[id.x] / smoothingRadius));
	ParticleHashTable[id.x] = GetHash(cellIndex);
	
}
\end{verbatim}

Skrót jest obliczany zgodnie z funkcją:\newline
\begin{verbatim}
float GetHash(int2 cellIndex)
{
	return ((cellIndex.x * 73856093) ^ (cellIndex.y * 19349663)) % hashTableSize;
}
\end{verbatim}

Kolejnym krokiem jest posortowanie cząstek wdług skrótu.\newline

Jądro sortowania cząsteczek wygląda następująco:\newline
\begin{verbatim}
    [numthreads(NumThreads, 1, 1)]
void SortParticlesByHash(uint3 id : SV_DispatchThreadID)
{
	uint partnerId = id.x ^ sortingDistance;
	bool ascending = ((id.x & sortingGroupSize) == 0);
	bool doSwap = (ascending && (ParticleHashTable[id.x] > ParticleHashTable[partnerId])) || (!ascending && (ParticleHashTable[id.x]  < ParticleHashTable[partnerId]));
	if (doSwap && partnerId > id.x && partnerId < numParticles)
	{
		uint tempUint = ParticleHashTable[id.x];
		ParticleHashTable[id.x] = ParticleHashTable[partnerId];
        ParticleHashTable[partnerId] = tempUint;
		
        float2 tempFloat2 = Positions[id.x];
        Positions[id.x] = Positions[partnerId];
		Positions[partnerId] = tempFloat2;
		
		tempFloat2 = PredictedPositions[id.x];
        PredictedPositions[id.x] = PredictedPositions[partnerId];
        PredictedPositions[partnerId] = tempFloat2;
		
		tempFloat2 = Velocities[id.x];
		Velocities[id.x] = Velocities[partnerId];
        Velocities[partnerId] = tempFloat2;
    }
}
\end{verbatim}

Oraz część kodu po stronie C# odpowiedzialna za odpowiednie wywołania na procesorze graficznym:\newline
\begin{verbatim}
for (int sortingGroupSize = 2; sortingGroupSize <= particleCount; sortingGroupSize *= 2)
{
    for (int sortingDistance = sortingGroupSize / 2; sortingDistance > 0; sortingDistance /= 2)
    {
        compute.SetInt("sortingGroupSize", sortingGroupSize);
        compute.SetInt("sortingDistance", sortingDistance);
        Dispatch(compute, particleCount, kernelIndex: sortParticlesByHashKernel);
    }
}
\end{verbatim}

Kolejnym krokiem jest zbudowanie tablicy szybkiego dostępu:\newline
\begin{verbatim}
[numthreads(NumThreads,1,1)]
void BuildHashOffsetTable(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= hashTableSize)
		return;
	for(uint i = 0; i < numParticles; i++)
	{
		if (ParticleHashTable[i] == id.x)
		{
			HashOffsetTable[id.x] = i;
			return;
		}
	}
    HashOffsetTable[id.x] = numParticles;
}
\end{verbatim}

Wykorzystanie powstałej struktury również wymaga odpowiedniej modyfikacji w jądrach wymagających dostępu do cząstek sąsiednich.\newline
\begin{verbatim}
[numthreads(NumThreads, 1, 1)]
void CalculateDensities(uint3 id : SV_DispatchThreadID)
{
	[...]
    
    int2 cellIndex = int2(floor(position / smoothingRadius));
    uint neighborHashes[9];
    GetNeighbouringCellHashes(cellIndex, neighborHashes);
	
    for (int i = 0; i < 9; i++)
    {
        uint currentHash = neighborHashes[i];
        if (currentHash == MAX_UINT)
            break;
        for (uint startIndex = HashOffsetTable[currentHash]; startIndex < numParticles && ParticleHashTable[startIndex] == currentHash; startIndex++)
        {
            [...]
        }
    }
    [...]
}
\end{verbatim}

Przez możliwość kolizji niemożliwe jest bezpośrednie sprawdzanie cząstek na podstawie otrzymanych skórtów. Wymagane jest wcześniejsze wyeliminowanie elementów powtarzających się, czym zajmuje się funkcja GetNeighbouringCellHashes(cellIndex, neighborHashes);\newline
\begin{verbatim}
void GetNeighbouringCellHashes(int2 cellIndex, out uint results[9])
{
	uint offsets[] = {
		-1, -1,
		-1, 0,
		-1, 1,
		 0, -1,
		 0, 0,
		 0, 1,
		 1, -1,
		 1, 0,
		 1, 1
	};
	
    uint idx = 0;
    for (int i = 0; i < 9; i++)
    {	
        results[idx] = MAX_UINT;
        uint hash = GetHash(cellIndex + int2(offsets[i * 2], offsets[i * 2 + 1]));
        bool found = false;
        for (int j = 0; j < i; j++)
        {
			if (results[j] == hash)
			{
				found = true;
				break;
            }
        }
        if (!found)
        {
            results[idx] = hash;
            idx++;
        }
    }
}
\end{verbatim}

\section{Badania}
\subsection{Unity Profiler}
Badania zostały przeprowadzone w środowisku Unity przy użyciu Unity Profiler.\newline
Unity Profiler pozwala na zbieranie i wizualizację danych odnośnie zużycia czasu procesora i pamięci przez poszczególne fragmenty programu.\newline
Narzędzie pozwala na inspekcję pojedynczych klatek pod względem wydajności celem optymalizacji pracy aplikacji.\newline
Narzędzie pozwala na wizualizację zasobu z podziałem na rodzaje zużycia tego zasobu.\newline
\begin{center}
    \includegraphics[width=7in]{profiler_wykres.png}
\end{center}
Unity Profiler zapewnia także widok hierarchiczy z dokładnymi parametrami wybranych części programmu, bądź wezwanych jąder procesora graficznego.\newline
\begin{center}
    \includegraphics[width=7in]{profiler_hierarhia.png}
\end{center}

\section{Podsumowanie}
\section{Wnioski}
\section{Bibliografia}

\end{document}
